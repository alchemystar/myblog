# 数字类型
|类型|有符号范围|无符号范围|长度|
| --- | :--- | :---: | ---: |
|tinyINT(n)|-128,127|0,255|1字节|
|smallINT(n)|-32768,23767|0,65535|2字节|
|mediumINT(n)|-8388608,8388607|0,16777215|3字节|
|int(n)|-2147483648,2147483647|0,4294967295|4字节|
|bigint(n)|-9223372036854775808,9223372036854775807|0,18446744073709551615|8字节|
|float|+(-)1.175494351E-38,+(-)3.402823466E+38||4字节|
|double|+(-)2.225073858072014E-308,+(-)1.7976931348623157E+308||8字节|


# 字符串类型

|类型| 长度 |长度允许范围|占用空间|备注|
| :---: | :---: | :---: |:---|:---|
|char(M)|固定为M|0,255|M\*每字符字节长度utf8下为3字节|会在右边填充空格达到指定长度,检索时会删除尾部所有空格|
|varchar(M)|可变长，最大为M|0,65535|M\*每字符字节长度+长度记录位|不进行填充，检索时保留尾部空格|

#时间类型
|类型|长度|时间范围|备注|
| :---: | :---: | :---: |:---|:---|
|TIMESTAMP|1970-01-01 00:00:00,2038(开区间)|4字节|以YYYY-MM-DD HH:MM:SS格式检索和显示|
|DATETIME|1000-01-01 00:00:00,9999-12-31 23:59:59|8字节|YYYY-MM-DD HH:MM:SS格式检索和显示|
|DATE|1000-01-01,9999-12-31|4字节|以YYYY-MM-DD格式检索和显示|

# 一些规范
|规范|
|:--|
|自增型主键统一为ID：使用auto_increment属性|
|单表行数不要超过一千万，超过一千万要提前分表(SSD五千万)|
|库表设计时请考虑相关数据清理工作，不允许一类表超过几亿行|
|不建议使用多表连接和全表遍历操作，建议通过主键或索引查询，表上的索引不宜过多|
|不要在线上数据库进行大的统计查询，客户端中止一条sql后，服务器端可能仍在运行|
|多条insert拼接成一条提交可以极大提高效率，比如1000条拼成一条；多条相关的更新语句可以放在一个事务中|
|批量update和delete数据时，可以采用delete from tablename where id in(id指定100个左右)，update tablename set cola='xxx'where id in (id指定100个左右)|
|删除数据较多时，要命中索引并增加limit，建议limit 10000|
|一个单表简单查询只能用到一个索引，需要用到多个字段请使用复合索引|
|大字段上添加索引可以考虑使用前缀索引，分页操作建议使用覆盖索引技术|
|text/blob类型的字段，建议单独建表，查询时按照主键直接命中|
|mysqldump导出数据时，使用default-character-set指定字符集|
# 基准测试数据

|存储|单表数据量SQL性能|建议|
|:--|:--|:--|
|SSD|单表数据量增加呈下降趋势，基本为线性|单表行数<5000W|
|SAS|单表数据量10W-2000W间迅速下降,2000W-5000W下降趋势趋于平缓，但qps已经较低|单表数据量<1000W|
 
# select基准数据

### 下面是单线程的数据，5线程的并发大约是单线程的4倍
|存储|select(<100W)|select(1000W)|select(2000W)|
|:--|:--|:--|:--|
|SSD|5000|4300|4000|
|SAS|5000|2300|1500|

|存储|update(<100W)|update(1000W)|update(2000W)|
|:--|:--|:--|:--|
|SSD|2800|4200|1800|
|SAS|2800|890|500|
#### 增量的insert，在2000W这个量级与单表数据量关系不大，大概2800QPS


### 主从复制的弊端
|主从复制|
|:--|
|Master可以并发写入，Slave只能串行同步(5.7已经可以并行)|
|Master上有大事务（t），Slave上会至少延迟时间t|
|Statement模式可能会导致主从数据不一致|
|Row模式会使binlog日志过大|
|层级过多会导致主从延迟严重|


### table_id

```
/*
  Each table share has a table id, it is mainly used for row based replication.
  Meanwhile it is used as table's version too.
*/
class Table_id
{
private:
  /* In table map event and rows events, table id is 6 bytes.*/
  static const ulonglong TABLE_ID_MAX= (~0ULL >> 16);
  ulonglong m_id;
  ......
}
```


|table_id增条件条件|
|:--|
|table变更|
|flush tables|
|table def cache过小，频繁换入换出导致增长过快|



|解决方案|
|:--|
|加大table cache的大小|
|重启主库使table_id归0,成本很高|
|修改MySQL源码，RPL\_TABLE\_LIST结构中的table_id修改为ulong型,一劳永逸|














